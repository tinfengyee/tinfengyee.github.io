(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{215:function(t,s,a){"use strict";a.r(s);var n=a(6),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"javascript深入之带你走进内存机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript深入之带你走进内存机制"}},[t._v("#")]),t._v(" JavaScript深入之带你走进内存机制")]),t._v(" "),a("p",[t._v("JS内存空间分为"),a("strong",[t._v("栈(stack)")]),t._v("、"),a("strong",[t._v("堆(heap)")]),t._v("、"),a("strong",[t._v("池(一般也会归类为栈中)")]),t._v("。 其中"),a("strong",[t._v("栈")]),t._v("存放变量，"),a("strong",[t._v("堆")]),t._v("存放复杂对象，"),a("strong",[t._v("池")]),t._v("存放常量，所以也叫常量池。")]),t._v(" "),a("p",[t._v("昨天文章介绍了堆和栈，小结一下：")]),t._v(" "),a("ul",[a("li",[t._v("基本类型：--\x3e "),a("code",[t._v("栈")]),t._v("内存（不包含闭包中的变量）")]),t._v(" "),a("li",[t._v("引用类型：--\x3e "),a("code",[t._v("堆")]),t._v("内存")])]),t._v(" "),a("p",[a("strong",[t._v("今日补充")]),t._v("一个知识点，就是闭包中的变量并不保存中栈内存中，而是保存在"),a("code",[t._v("堆内存")]),t._v("中，这也就解释了函数之后之后为什么闭包还能引用到函数内的变量。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("B")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("code",[t._v("闭包")]),t._v("的简单定义是：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。")]),t._v(" "),a("p",[t._v("函数 A 弹出调用栈后，函数 A 中的变量这时候是存储在堆上的，所以函数B依旧能引用到函数A中的变量。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。")]),t._v(" "),a("h2",{attrs:{id:"内存回收"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存回收"}},[t._v("#")]),t._v(" 内存回收")]),t._v(" "),a("p",[t._v("JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("局部变量和全局变量的销毁")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("局部变量")]),t._v("：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。")]),t._v(" "),a("li",[a("strong",[t._v("全局变量")]),t._v("：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量"),a("strong",[t._v("避免")]),t._v("使用全局变量。")])])]),t._v(" "),a("li",[a("p",[t._v("以Google的V8引擎为例，V8引擎中所有的JS对象都是通过")]),t._v(" "),a("p",[t._v("堆")]),t._v(" "),a("p",[t._v("来进行内存分配的")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("初始分配")]),t._v("：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。")]),t._v(" "),a("li",[a("strong",[t._v("继续申请")]),t._v("：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。")])])]),t._v(" "),a("li",[a("p",[t._v("V8引擎对堆内存中的JS对象进行")]),t._v(" "),a("p",[t._v("分代管理")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("新生代")]),t._v("：存活周期较短的JS对象，如临时变量、字符串等。")]),t._v(" "),a("li",[a("strong",[t._v("老生代")]),t._v("：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。")])])])]),t._v(" "),a("h2",{attrs:{id:"垃圾回收算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[t._v("#")]),t._v(" 垃圾回收算法")]),t._v(" "),a("p",[t._v("对垃圾回收算法来说，核心思想就是如何判断内存已经不再使用，常用垃圾回收算法有下面两种。")]),t._v(" "),a("ul",[a("li",[t._v("引用计数（现代浏览器不再使用）")]),t._v(" "),a("li",[t._v("标记清除（常用）")])]),t._v(" "),a("h3",{attrs:{id:"引用计数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[t._v("#")]),t._v(" 引用计数")]),t._v(" "),a("p",[t._v("引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的"),a("strong",[t._v("引用")]),t._v("。如果没有其他对象指向它了，说明该对象已经不再需要了。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 创建一个对象person，他有两个指向属性age和name的引用")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" person "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    age"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'aaaa'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nperson"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 虽然name设置为null，但因为person对象还有指向name的引用，因此name不会回收")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" person"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \nperson "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("         "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收")]),t._v("\n\np "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("           "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//原person对象已经没有引用，很快会被回收")]),t._v("\n")])])]),a("p",[t._v("引用计数有一个致命的问题，那就是"),a("strong",[t._v("循环引用")])]),t._v(" "),a("p",[t._v("如果两个对象相互引用，尽管他们已不再使用，但是垃圾回收器不会进行回收，最终可能会导致内存泄露。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("cycle")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" o1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" o2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    o1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" o2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    o2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" o1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"cycle reference!"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("cycle")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[a("code",[t._v("cycle")]),t._v("函数执行完成之后，对象"),a("code",[t._v("o1")]),t._v("和"),a("code",[t._v("o2")]),t._v("实际上已经不再需要了，但根据引用计数的原则，他们之间的相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器"),a("strong",[t._v("不再使用")]),t._v("这个算法。")]),t._v(" "),a("p",[t._v("但是IE依旧使用。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" div "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"div"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndiv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("onclick")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"click"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("上面的写法很常见，但是上面的例子就是一个循环引用。")]),t._v(" "),a("p",[t._v("变量div有事件处理函数的引用，同时事件处理函数也有div的引用，因为div变量可在函数内被访问，所以循环引用就出现了。")]),t._v(" "),a("h3",{attrs:{id:"标记清除-常用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记清除-常用"}},[t._v("#")]),t._v(" 标记清除（常用）")]),t._v(" "),a("p",[t._v("标记清除算法将“不再使用的对象”定义为“"),a("strong",[t._v("无法到达的对象")]),t._v("”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，"),a("strong",[t._v("保留")]),t._v("。那些从根部出发无法触及到的对象被标记为"),a("strong",[t._v("不再使用")]),t._v("，稍后进行回收。")]),t._v(" "),a("p",[t._v("无法触及的对象包含了没有引用的对象这个概念，但反之未必成立。")]),t._v(" "),a("p",[t._v("所以上面的例子就可以正确被垃圾回收处理了。")]),t._v(" "),a("p",[t._v("所以现在对于主流浏览器来说，只需要切断需要回收的对象与根部的联系。最常见的内存泄露一般都与DOM元素绑定有关：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("email"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("message "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("createElement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("“div”"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ndisplayList"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("appendChild")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("email"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("message"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 稍后从displayList中清除DOM元素")]),t._v("\ndisplayList"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("removeAllChildren")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("上面代码中，"),a("code",[t._v("div")]),t._v("元素已经从DOM树中清除，但是该"),a("code",[t._v("div")]),t._v("元素还绑定在email对象中，所以如果email对象存在，那么该"),a("code",[t._v("div")]),t._v("元素就会一直保存在内存中。")]),t._v(" "),a("h2",{attrs:{id:"内存泄漏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏"}},[t._v("#")]),t._v(" 内存泄漏")]),t._v(" "),a("p",[t._v("对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 对于不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）")]),t._v(" "),a("h2",{attrs:{id:"内存泄漏识别方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏识别方法"}},[t._v("#")]),t._v(" 内存泄漏识别方法")]),t._v(" "),a("h3",{attrs:{id:"_1、浏览器方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、浏览器方法"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"https://muyiy.cn/blog/1/1.4.html#_1%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%96%B9%E6%B3%95",target:"_blank",rel:"noopener noreferrer"}},[t._v("#"),a("OutboundLink")],1),t._v("1、浏览器方法")]),t._v(" "),a("ol",[a("li",[t._v("打开开发者工具，选择 Memory")]),t._v(" "),a("li",[t._v("在右侧的Select profiling type字段里面勾选 timeline")]),t._v(" "),a("li",[t._v("点击左上角的录制按钮。")]),t._v(" "),a("li",[t._v("在页面上进行各种操作，模拟用户的使用情况。")]),t._v(" "),a("li",[t._v("一段时间后，点击左上角的 stop 按钮，面板上就会显示这段时间的内存占用情况。")])]),t._v(" "),a("h3",{attrs:{id:"_2、命令行方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、命令行方法"}},[t._v("#")]),t._v(" 2、命令行方法")]),t._v(" "),a("p",[t._v("使用 "),a("code",[t._v("Node")]),t._v(" 提供的 "),a("code",[t._v("process.memoryUsage")]),t._v(" 方法。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("process"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("memoryUsage")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 输出")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n  rss"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("27709440")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// resident set size，所有内存占用，包括指令区和堆栈")]),t._v("\n  heapTotal"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5685248")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// "堆"占用的内存，包括用到的和没用到的')]),t._v("\n  heapUsed"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3449392")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用到的堆的部分")]),t._v("\n  external"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("8772")]),t._v(" \t\t"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// V8 引擎内部的 C++ 对象占用的内存")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("判断内存泄漏，以"),a("code",[t._v("heapUsed")]),t._v("字段为准。")]),t._v(" "),a("p",[t._v("详细的JS内存分析将在"),a("a",{attrs:{href:"https://muyiy.cn/blog/1/1.4.html#",target:"_blank",rel:"noopener noreferrer"}},[t._v("【进阶20期】性能优化"),a("OutboundLink")],1),t._v("详细介绍，敬请期待")]),t._v(" "),a("h2",{attrs:{id:"weakmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#weakmap"}},[t._v("#")]),t._v(" WeakMap")]),t._v(" "),a("p",[t._v("ES6 新出的两种数据结构："),a("code",[t._v("WeakSet")]),t._v(" 和 "),a("code",[t._v("WeakMap")]),t._v("，表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" wm "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("WeakMap")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" element "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'example'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nwm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("element"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'some information'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nwm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("element"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// "some information"')]),t._v("\n")])])]),a("p",[t._v("先新建一个 "),a("code",[t._v("Weakmap")]),t._v(" 实例，然后将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 "),a("code",[t._v("WeakMap")]),t._v(" 里面。这时，"),a("code",[t._v("WeakMap")]),t._v(" 里面对element的引用就是弱引用，不会被计入垃圾回收机制。")])])}),[],!1,null,null,null);s.default=e.exports}}]);