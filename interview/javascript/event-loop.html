<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>理解事件循环(Event Loop) | Tinf - 天枫前端</title>
    <meta name="generator" content="VuePress 1.6.0">
    
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/assets/css/0.styles.a748b10c.css" as="style"><link rel="preload" href="/assets/js/app.e14173b0.js" as="script"><link rel="preload" href="/assets/js/2.138148d6.js" as="script"><link rel="preload" href="/assets/js/6.96633f40.js" as="script"><link rel="prefetch" href="/assets/js/10.c02206a3.js"><link rel="prefetch" href="/assets/js/11.4c742e8d.js"><link rel="prefetch" href="/assets/js/12.72d1855f.js"><link rel="prefetch" href="/assets/js/13.f0ead50a.js"><link rel="prefetch" href="/assets/js/14.7b0ea7df.js"><link rel="prefetch" href="/assets/js/15.33e33d62.js"><link rel="prefetch" href="/assets/js/16.e1106ac7.js"><link rel="prefetch" href="/assets/js/17.866c16d5.js"><link rel="prefetch" href="/assets/js/18.9b2506f4.js"><link rel="prefetch" href="/assets/js/19.980d1179.js"><link rel="prefetch" href="/assets/js/20.1bdc7940.js"><link rel="prefetch" href="/assets/js/21.fcd85543.js"><link rel="prefetch" href="/assets/js/22.83e28c6e.js"><link rel="prefetch" href="/assets/js/23.fb0c5378.js"><link rel="prefetch" href="/assets/js/24.e6239085.js"><link rel="prefetch" href="/assets/js/25.8d379376.js"><link rel="prefetch" href="/assets/js/26.1f460d6a.js"><link rel="prefetch" href="/assets/js/27.6c4c0804.js"><link rel="prefetch" href="/assets/js/28.e5d23c87.js"><link rel="prefetch" href="/assets/js/29.919c566f.js"><link rel="prefetch" href="/assets/js/3.0b45e66b.js"><link rel="prefetch" href="/assets/js/30.ead3cff0.js"><link rel="prefetch" href="/assets/js/31.a45ebc0e.js"><link rel="prefetch" href="/assets/js/32.49abf061.js"><link rel="prefetch" href="/assets/js/33.a1989b16.js"><link rel="prefetch" href="/assets/js/34.42173ec9.js"><link rel="prefetch" href="/assets/js/35.d0170793.js"><link rel="prefetch" href="/assets/js/36.4c5dcc7b.js"><link rel="prefetch" href="/assets/js/37.511525c0.js"><link rel="prefetch" href="/assets/js/38.2650afdc.js"><link rel="prefetch" href="/assets/js/4.587e6ad5.js"><link rel="prefetch" href="/assets/js/5.4643ad0b.js"><link rel="prefetch" href="/assets/js/7.3b9035ab.js"><link rel="prefetch" href="/assets/js/8.f80a383d.js"><link rel="prefetch" href="/assets/js/9.92a50533.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a748b10c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt="Tinf - 天枫前端" class="logo"> <span class="site-name can-hide">Tinf - 天枫前端</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/article/" class="nav-link">
  Article
</a></div><div class="nav-item"><a href="/interview/" class="nav-link router-link-active">
  Interview
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/recommend/" class="nav-link">
  Recommend
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Contact" class="dropdown-title"><span class="title">Contact</span> <span class="arrow down"></span></button> <button type="button" aria-label="Contact" class="mobile-dropdown-title"><span class="title">Contact</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/tinfengyee" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://space.bilibili.com/12445328" target="_blank" rel="noopener noreferrer" class="nav-link external">
  bilibili
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://weibo.com/tinfengyee" target="_blank" rel="noopener noreferrer" class="nav-link external">
  微博
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/article/" class="nav-link">
  Article
</a></div><div class="nav-item"><a href="/interview/" class="nav-link router-link-active">
  Interview
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><a href="/recommend/" class="nav-link">
  Recommend
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Contact" class="dropdown-title"><span class="title">Contact</span> <span class="arrow down"></span></button> <button type="button" aria-label="Contact" class="mobile-dropdown-title"><span class="title">Contact</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/tinfengyee" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://space.bilibili.com/12445328" target="_blank" rel="noopener noreferrer" class="nav-link external">
  bilibili
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://weibo.com/tinfengyee" target="_blank" rel="noopener noreferrer" class="nav-link external">
  微博
  <svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/interview/" aria-current="page" class="sidebar-link">文章目录</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>h5c3</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="理解事件循环-event-loop"><a href="#理解事件循环-event-loop" class="header-anchor">#</a> 理解事件循环(Event Loop)</h1> <p>我们知道了事件循环的本质是一个 user agent 上协调各类事件的机制，这一节我们主要讨论一下浏览器中的这个机制与 JavaScript 的交互部分。</p> <h2 id="浏览器内核"><a href="#浏览器内核" class="header-anchor">#</a> 浏览器内核</h2> <p>简单来说浏览器内核是通过取得页面内容、整理信息（应用 CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p> <p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p> <ul><li>GUI 渲染线程</li> <li>JavaScript 引擎线程</li> <li>定时触发器线程</li> <li>事件触发线程</li> <li>异步 http 请求线程</li></ul> <p><strong>1. GUI 渲染线程</strong></p> <ul><li>主要负责页面的渲染，解析 HTML、CSS，构建 DOM 树，布局和绘制等。</li> <li>当界面需要重绘或者由于某种操作引发回流时，将执行该线程。</li> <li>该线程与 JS 引擎线程互斥，当执行 JS 引擎线程时，GUI 渲染会被挂起，当任务队列空闲时，JS 引擎才会去执行 GUI 渲染。</li></ul> <p><strong>2. JS 引擎线程</strong></p> <ul><li>该线程当然是主要负责处理 JavaScript 脚本，执行代码。</li> <li>也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS 引擎线程的执行。</li> <li>当然，该线程与 GUI 渲染线程互斥，当 JS 引擎线程执行 JavaScript 脚本时间过长，将导致页面渲染的阻塞。</li></ul> <p><strong>3. 定时器触发线程</strong></p> <ul><li>负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。</li> <li>主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待 JS 引擎线程执行。</li></ul> <p><strong>4. 事件触发线程</strong></p> <ul><li>主要负责将准备好的事件交给 JS 引擎线程执行。</li></ul> <p>比如 setTimeout 定时器计数结束， ajax 等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS 引擎线程的执行。</p> <p><strong>5. 异步 http 请求线程</strong></p> <ul><li>负责执行异步请求一类的函数的线程，如： Promise，axios，ajax 等。</li> <li>主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待 JS 引擎线程执行</li></ul> <blockquote><p>以 Chrome 浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁</p></blockquote> <h2 id="为什么需要事件循环"><a href="#为什么需要事件循环" class="header-anchor">#</a> 为什么需要事件循环</h2> <p>先看<a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="noopener noreferrer">HTML标准<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的一系列解释：</p> <blockquote><p><strong>为了协调事件</strong>（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。
有两类事件循环：一种针对浏览上下文（browsing context），还有一种针对worker（web worker）。</p></blockquote> <h3 id="同步异步"><a href="#同步异步" class="header-anchor">#</a> 同步异步</h3> <p><strong>js 是一门单线程语言</strong> ，必然不会存在同时执行的另一行代码。js 引擎有一个主线程（main thread）用来解释和执行 js 程序，实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在node.js中)等等。这些线程可能存在于 js 引擎之内，也可能存在于 js 引擎之外，在此我们不做区分。不妨叫它们工作线程。</p> <p>任务分为同步任务（synchronous）和异步任务（asynchronous），如果所有任务都由主线程来处理，会出现主线程被阻塞而使得页面“假死”。为了主线程不被阻塞，异步任务（如：AJAX异步请求，定时器等）就会交给工作线程来处理，异步任务完成后将异步回调函数注册进任务队列，等待主线程空闲时调用。</p> <h2 id="理解事件循环"><a href="#理解事件循环" class="header-anchor">#</a> 理解事件循环</h2> <p>现在我们知道了浏览器运行时有一个叫<strong>事件循环</strong>的机制。</p> <blockquote><p>一个事件循环有一个或者多个<code>任务队列</code>（task queues）。任务队列是task的有序列表，这些task是以下工作的对应算法：Events，Parsing，Callbacks，Using a resource，Reacting to DOM manipulation。</p> <p>每一个任务都来自一个特定的<code>任务源</code>（task source）。所有来自一个特定任务源并且属于特定事件循环的任务，通常必须被加入到同一个任务队列中，但是来自不同任务源的任务可能会放在不同的任务队列中。</p> <p>举个例子，用户代理有一个处理鼠标和键盘事件的任务队列。用户代理可以给这个队列比其他队列多3/4的执行时间，以确保交互的响应而不让其他任务队列饿死（starving），并且不会乱序处理任何一个任务队列的事件。</p> <p>每个事件循环都有一个进入<code>microtask</code>检查点（performing a microtask checkpoint）的flag标志，这个标志初始为false。它被用来组织反复调用‘进入microtask检查点’的算法。</p></blockquote> <p>总结一下，一个事件循环里有很多个任务队列（task queues）来自不同任务源，每一个任务队列里的任务是严格按照先进先出的顺序执行的，但是不同任务队列的任务的执行顺序是不确定的。按我的理解就是，浏览器会自己<strong>调度</strong>不同任务队列。网上很多文章会提到<code>macrotask</code>这个概念，其实就是指代了标准里阐述的<code>task</code>。</p> <h3 id="初步理解事件循环"><a href="#初步理解事件循环" class="header-anchor">#</a> 初步理解事件循环</h3> <p>下面来看一段代码,想想它的结果和你的结果是否一样</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    
    <span class="token comment">//  执行结果是 </span>





    <span class="token comment">// 2 1</span>
</code></pre></div><p>我们可以将<code>js</code>的任务分为<strong>同步任务</strong>和<strong>异步任务</strong>, 按照这种分类<code>js</code>的执行机制如下</p> <ul><li>任务执行队列分为<strong>同步任务队列</strong>和<strong>异步任务队列</strong></li> <li>代码执行时，遇到同步代码，会被直接推入**同步任务队列(执行栈)**并依次执行</li> <li>遇到异步代码(如<code>setTimeout、setInterval</code>), 会被直接推入<strong>异步任务队列</strong></li> <li>当<strong>同步任务队列</strong>执行完毕，这个时候<strong>异步任务队列</strong>的任务会被依次推入<strong>同步任务队列</strong>并依次执行</li></ul> <p>所以上面的代码执行的时候, <code>setTimeout()</code>不会被立即执行，会被推到<strong>异步任务队列里面</strong>, 之后再执行<code>console.log(2)</code>, <strong>同步任务队列</strong>任务执行完毕之后，会去<strong>异步任务队列</strong>的任务会被依次推到 <strong>同步任务队列</strong>并执行</p> <h3 id="进一步理解理解事件循环"><a href="#进一步理解理解事件循环" class="header-anchor">#</a> 进一步理解理解事件循环</h3> <p>下面来看一段代码,想想它的结果和你的结果是否一样</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>

<span class="token comment">// 执行结果是 </span>






<span class="token comment">//  2 4 3 1</span>
</code></pre></div><p><code>js</code><strong>异步任务</strong>按照准确的划分，应该将任务分为</p> <ul><li>宏任务task： script（整体代码）、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate（node.js 环境）</li> <li>微任务micro-task： Promise.then、MutaionObserver(html5 新特性)、MessageChannel、process.nextTick（node.js 环境）。<em>注意<code>new Promsie()</code>的时候是同步，立即执行。</em></li></ul> <p>注： 宏任务队列指的是<code>Task Queue</code>， 也被称为<code>macro-task queue</code>，属于<strong>外部队列</strong>,顾名思义就是 JavaScript 外部的事件的队列，由宿主环境提供(浏览器内核或者node), 这里我们可以先列举一下浏览器中这些外部事件源（Task Source），他们主要有：</p> <ul><li>DOM 操作 (页面渲染)</li> <li>用户交互 (鼠标、键盘)</li> <li>网络请求 (Ajax 等)</li> <li>History API 操作</li> <li>定时器 (setTimeout 等)</li></ul> <hr> <p><strong>注意: 现在有三个队列: 同步队列(也称执行栈)、宏任务队列、微任务队列</strong></p> <p>所以针对这种机制，<code>js</code>的事件循环机制应该是这样的</p> <ul><li>遇到同步代码，依次推入<strong>同步队列</strong>并执行</li> <li>当遇到<code>setTimeout、setInterval</code>,会被推到<strong>宏任务队列</strong></li> <li>如果遇到<code>.then</code>，会被当作<strong>微任务</strong>，被推入<strong>微任务</strong>队列</li> <li>同步队列执行完毕，然后会去微队列取任务，直到微队列清空。然后检查宏队列，去宏队列取任务，并且每一个宏任务执行完毕都会去微队列跑一遍，看看有没有新的微任务，有的话再把微任务清空。这样依次循环</li></ul> <div class="language-js extra-class"><pre class="language-js"><code> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
 <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>所以对于以上的代码执行流程如下:</p> <ol><li>遇到同步任务先输出1。</li> <li><code>setTimeout</code>是宏任务，会先放到宏任务队列中。</li> <li><code>new Promise</code>是立即执行的，所以会先输出3。</li> <li>而<code>Promise.then</code>是微任务，会依次排列到微任务队列中，继续向下执行输出2。</li> <li>现在执行栈中的任务已经清空，再将微任务队列清空，依次输出100和200。</li> <li>然后每次取出一个宏任务，因为现在只有一个宏任务，所以最后输出<code>setTimeout</code>。</li></ol> <p>如下图，内部任务指的是微任务， 外部任务指的是宏任务。</p> <p><img src="/assets/img/event-loop.cc897b14.png" alt="event-loop"></p> <h3 id="async-await"><a href="#async-await" class="header-anchor">#</a> async/await</h3> <p>async、await是一个语法糖，使异步代码转为同步代码运行。</p> <p><strong>async</strong></p> <p>当我们在函数前使用<code>async</code>的时候，使得该函数返回的是一个<code>Promise</code>对象</p> <p>当我们在函数前使用<code>async</code>的时候，使得该函数返回的是一个<code>Promise</code>对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span>   <span class="token comment">// async的函数会在这里帮我们隐士使用Promise.resolve(1)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 等价于下面的代码</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 等于</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>await</strong></p> <p><code>await</code>表示等待，是右侧「表达式」的<strong>结果</strong>，这个表达式的计算结果可以是 Promise 对象的值或者一个函数的值（换句话说，就是没有特殊限定）。并且只能在带有<code>async</code>的内部使用</p> <p>使用<code>await</code>时，会从右往左执行，当遇到<code>await</code>时，会阻塞函数内部处于它后面的代码，去执行该函数外部的同步代码，当外部同步代码执行完毕，再回到该函数内部执行剩余的代码, 并且当<code>await</code>执行完毕之后，<s>会先处理微任务队列的代码</s>(<em>原文这句话可能已经不适用</em>)， （注意:<strong>外部的微任务还是要等await函数后面代码执行完</strong>）</p> <p>下面来看一个栗子:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 start'</span><span class="token punctuation">)</span>
	<span class="token keyword">await</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async1 end'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">async2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'async2'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token function">async1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
	<span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>
</code></pre></div><p>(与原文有出入)</p> <p>输出结果</p> <div class="language- extra-class"><pre class="language-text"><code>script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
</code></pre></div><p><strong>使用事件循环机制分析:</strong></p> <ol><li>首先执行同步代码，<code>console.log( 'script start' )</code></li> <li>遇到<code>setTimeout</code>,会被推入<strong>宏任务队列</strong></li> <li>执行<code>async1()</code>, 它也是同步的，只是返回值是<code>Promise</code>，在内部首先执行<code>console.log( 'async1 start' )</code></li> <li>后执行<code>async2()</code>, 然后会打印<code>console.log( 'async2' )</code></li> <li>从右到左会执行, 当遇到<code>await</code>的时候，阻塞后面的代码，去外部执行<strong>同步代码</strong></li> <li>进入<code>new Promise</code>,打印<code>console.log( 'promise1' )</code></li> <li>将<code>.then</code>放入事件循环的<strong>微任务队列</strong></li> <li>继续执行，打印<code>console.log( 'script end' )</code></li> <li>外部同步代码执行完毕，接着回到<code>async1()</code>内部, 执行后面的代码, 打印<code>console.log( 'async1 end' )</code>，</li> <li>由于<code>async2()</code>其实是返回一个<code>Promise</code>, <code>await async2()</code>相当于获取它的值，其实就相当于这段代码<code>Promise.resolve(undefined).then((undefined) =&gt; {})</code>,所以<code>.then</code>会被推入微任务队列, 所以现在<strong>微任务队列</strong>会有两个任务。接下来处理<strong>微任务队列</strong>，打印<code>console.log( 'promise2' )</code></li> <li>进入第二次事件循环，执行宏任务队列, 打印<code>console.log( 'setTimeout' )</code></li></ol> <h2 id="浏览器和node事件循环的差异"><a href="#浏览器和node事件循环的差异" class="header-anchor">#</a> 浏览器和node事件循环的差异</h2> <p>关键词： <strong>(node v11之前， node的宏任务有权重)</strong></p> <p>遇到有人问怎么确定一个异步任务是宏任务还是微任务?这是约定俗成的事吗?</p> <blockquote><p>宿主环境提供的方法是宏任务，例如setTimeout, setInterval。这些都是浏览器或者Node环境实现的。js引擎自身提供的是微任务，例如Promise。基本上平时接触道德除了Promise都是宏任务。出自评论区-<a href="https://juejin.im/post/6844903657264136200" target="_blank" rel="noopener noreferrer">微任务、宏任务与Event-Loop<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <p>根据本文开头我们讨论的事件循环起源(来自<strong>推荐3</strong>的文章)，很容易理解为什么浏览器与 Node.js 的事件循环会存在差异。如果说浏览端是将 JavaScript 集成到 HTML 的事件循环 [2] 之中，那么 Node.js 则是将 JavaScript 集成到 libuv 的 I/O 循环 [8] 之中。</p> <p>简而言之，二者都是把 JavaScript 集成到他们各自的环境中，但是 HTML (浏览器端) 与 libuv (服务端) 面对的场景有很大的差异。首先能直观感受到的区别是：</p> <ol><li>事件循环的过程没有 HTML 渲染。只剩下了外部队列和内部队列这两个部分。</li> <li>外部队列的事件源不同。Node.js 端没有了鼠标等外设但是新增了文件等 IO。</li> <li>内部队列的事件仅剩下 Promise 的 then 和 catch。</li></ol> <p>至于内在的差异，有一个很重要的地方是 Node.js （libuv）在最初设计的时候是允许执行多次外部的事件再切换到内部队列的，而浏览器端一次事件循环只允许执行一次外部事件。这个经典的内在差异，可以通过以下例子来观察：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这个例子在浏览器端执行的结果是 <code>timer1</code> -&gt; <code>promise1</code> -&gt; <code>timer2</code> -&gt; <code>promise2</code>，而在 Node.js 早期版本（11 之前）执行的结果却是 <code>timer1</code> -&gt; <code>timer2</code> -&gt; <code>promise1</code> -&gt; <code>promise2</code>。</p> <p>究其原因，主要是因为<strong>浏览器端有外部队列(宏任务队列-Task Queue)一次事件循环只能执行一个的限制</strong>，而在 Node.js 中则放开了这个限制，允许外部队列中所有任务都执行完再切换到内部队列(微任务队列-Microtask Queue)。所以他们的情况对应为：</p> <ul><li><p>浏览器端</p></li> <li><ol><li>外部队列：代码执行，两个 timeout 加入外部队列</li> <li>内部队列：空</li> <li>外部队列：第一个 timeout 执行，promise 加入内部队列</li> <li>内部队列：执行第一个 promise</li> <li>外部队列：第二个 timeout 执行，promise 加入内部队列</li> <li>内部队列：执行第二个 promise</li></ol></li> <li><p>Node.js 服务端</p></li> <li><ol><li>外部队列：代码执行，两个 timeout 加入外部队列</li> <li>内部队列：空</li> <li>外部队列：两个 timeout 都执行完</li> <li>内部队列：两个 promise 都执行完</li></ol></li></ul> <p>虽然 Node.js 的这个问题在 11 之后的版本里修复了，但是为了继续探究这个影响，我们引入一个新的外部事件 setImmediate。这个方法目前是 Node.js 独有的，浏览器端没有。</p> <p>setImmediate 的引入是为了解决 setTimeout 的精度问题，由于 setTimeout 指定的延迟时间是毫秒（ms）但实际一次时间循环的时间可能是纳秒级的，所以在一次事件循环的多个外部队列中，找到某一个队列直接执行其中的 callback 可以得到比 setTimeout 更早执行的效果。我们继续以开始的场景构造一个例子，并在 Node.js 10.x 的版本上执行（存在一次事件循环执行多次外部事件）：</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setImmediate1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise3'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setImmediate2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise4'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>输出结果：</p> <div class="language-js extra-class"><pre class="language-js"><code>setImmediate1
setImmediate2
promise3
promise4
setTimeout1
setTimeout2
promise1
promise2
</code></pre></div><p>根据这个执行结果 [12]，我们可以推测出 Node.js 中的事件循环与浏览器类似，也是外部队列与内部队列的循环，而 setImmediate 在另外一个外部队列中。</p> <p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/s4gib6lJMMRcEpLCb2Aib8MKfda6vutnybcXdKGRtLDrrHgRzOXy7v6XuofR8HEPcic631kvFfNXu6rFTC9kaibbbA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p> <p>接下来，我们再来看一下当 Node.js(v11) 在与浏览器端对齐了事件循环的事件之后，这个例子的执行结果为：</p> <div class="language-js extra-class"><pre class="language-js"><code>setImmediate1
promise3
setImmediate2
promise4
setTimeout1
promise1
setTimeout2
promise2
</code></pre></div><p>其中主要有两点需要关注，一是外部列队在每次事件循环只执行了一个，另一个是 Node.js 的固定了多个外部队列的优先级。setImmediate 的外部队列没有执行完的时候，是不会执行 timeout 的外部队列的。了解了这个点之后，Node.js 的事件循环就变得很简单了，我们可以看下 Node.js 官方文档 [9] 中对于事件循环顺序的展示：</p> <p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/s4gib6lJMMRcEpLCb2Aib8MKfda6vutnybCFEapwgfPL5ia2E6qjjZ36u6zsickBhDH3NcKibS1TicPZlnibI7wJx5Zyw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p> <p>其中 check 阶段是用于执行 setImmediate 事件的。结合本文上面的推论我们可以知道，Node.js 官方这个所谓事件循环过程，其实只是完整的事件循环中 Node.js 的多个外部队列相互之间的优先级顺序。</p> <p>我们可以在加入一个 poll 阶段的例子来看这个循环：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setImmediate'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

fs<span class="token punctuation">.</span><span class="token function">readdir</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fs.readdir'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>输出结果（v12.x）： setTimeout比setImmediate先执行。</p> <div class="language-js extra-class"><pre class="language-js"><code>promise
setTimeout
fs<span class="token punctuation">.</span>readdir
setImmediate
</code></pre></div><p>根据输出结果，我们可以知道梳理出来：</p> <ol><li>外部队列：执行当前 script</li> <li>内部队列：执行 promise</li> <li>外部队列：执行 setTimeout</li> <li>内部队列：空</li> <li>外部队列：执行 fs.readdir</li> <li>内部队列：空</li> <li>外部队列：执行 check （setImmediate）</li></ol> <p>这个顺序符合 Node.js 对其外部队列的优先级定义：</p> <p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/s4gib6lJMMRcEpLCb2Aib8MKfda6vutnybaxdku4sgMgLmU3zicViayplDZwWFCFibp4viaZ7J3SxOwcqbByTK420qzA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p> <p>timer（setTimeout）是第一阶段的原因在 libuv 的文档 [8] 中有描述 —— 为了减少时间相关的系统调用（System Call）。setImmediate 出现在 check 阶段是蹭了 libuv 中 poll 阶段之后的检查过程（这个过程放在 poll 中也很奇怪，放在 poll 之后感觉比较合适）。</p> <p><code>idle, prepare</code> 对应的是 libuv 中的两个叫做 idle [10] 和 prepare [11] 的句柄。由于 I/O 的 poll 过程可能阻塞住事件循环，所以这两个句柄主要是用来触发 poll （阻塞）之前需要触发的回调：</p> <p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/s4gib6lJMMRcEpLCb2Aib8MKfda6vutnybA53UickR6y4AYNFKA71v6mQO6DkNBl4jjhtj8ebzlrE1p0I4nglcXsw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p> <p>由于 poll 可能 block 住事件循环，所以应当有一个外部队列专门用于执行 I/O 的 callback ，并且优先级在 poll 以及 prepare to poll 之前。</p> <p>另外我们知道网络 IO 可能有非常多的请求同时进来，如果该阶段如果无限制的执行这些 callback，可能导致 Node.js 的进程卡死该阶段，其他外部队列的代码都没法执行了。所以当前外部队列在执行一定数量的 callback 之后会截断。由于截断的这个特性，这个专门执行 I/O callbacks 的外部队列也叫 <code>pengding callbacks</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>   ┌───────────────────────────┐
┌─&gt;│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │&lt;─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
└──│           check           │
   └───────────────────────────┘
</code></pre></div><p>至此 Node.js 多个外部队列的优先级已经演化到类似原版的程度。最后剩下的 socket close 为什么是在 check 和 timers 之间，这个具体的权衡留待大家一起探讨，博主这里已经肝不动了。</p> <p>关于浏览器与 Node.js 的事件循环，如果你要问我那边更加简单，那么我肯定会说是 Node.js 的事件循环更加简单，因为它的多个外部队列是可枚举的并且优先级是固定的。但是浏览器端在对它的多个外部队列做优先级排列的时候，我们一没法枚举，二不清楚其优先级策略，甚至浏览器端的事件循环可能是基于多线程或者多进程的（HTML 的标准中并没有规定一定要使用单线程来实现事件循环）。</p> <p>（建议自己查看原文<code>推荐3</code>）</p> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <blockquote><p>参考自己看看吧， 各有不同理解，看推荐的比较容易懂。注意node和浏览器的区别。</p></blockquote> <ul><li><p><a href="https://segmentfault.com/a/1190000017554062" target="_blank" rel="noopener noreferrer">js事件循环机制(浏览器端Event Loop) 以及async/await的理解<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <code>推荐1*</code></p></li> <li><p><a href="https://juejin.im/post/6844903657264136200" target="_blank" rel="noopener noreferrer">微任务、宏任务与Event-Loop<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><code>推荐2</code></p></li> <li><p><a href="https://segmentfault.com/a/1190000010622146" target="_blank" rel="noopener noreferrer">什么是浏览器的事件循环（Event Loop）<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><code>推荐</code></p></li> <li><p><a href="https://mp.weixin.qq.com/s/IhaHIh-G1wQg8Tdc0nxP4Q" target="_blank" rel="noopener noreferrer">JavaScript 事件循环：从起源到浏览器再到 Node.js<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><code>推荐3*</code>(也讲到了环境的区别，比较新)</p></li> <li><p><a href="https://mp.weixin.qq.com/s/rqxE2S-O_JbX14wCvhwMrw" target="_blank" rel="noopener noreferrer">深入解析 EventLoop 和浏览器渲染、帧动画、空闲回调的关系<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><code>推荐</code></p></li> <li><p><a href="https://segmentfault.com/a/1190000015042127" target="_blank" rel="noopener noreferrer">Event Loop - JS执行机制<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><code>推荐</code></p></li> <li><p><a href="https://segmentfault.com/a/1190000016295324" target="_blank" rel="noopener noreferrer">对于js任务队列的理解<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NDQ0ODU3MA==&amp;mid=2247486118&amp;idx=1&amp;sn=5a27f7eb5afde72740750a45ba44a8a4&amp;chksm=e95ce6f3de2b6fe5be7acc80317965d2bf7d1800941fd47bde9b080b87409febfe64cd6adceb&amp;token=1734057872&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">【动画演示】：事件循环 形象深动(JavaScript)<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p><a href="https://github.com/qq449245884/xiaozhi/issues/4" target="_blank" rel="noopener noreferrer">JavaScript是如何工作的:事件循环和异步编程的崛起+5种使用 async/await 更好地编码方式<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p><a href="https://www.cnblogs.com/mp-0518/p/11235957.html" target="_blank" rel="noopener noreferrer">微任务和宏任务的区别<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p><a href="https://segmentfault.com/a/1190000013660033" target="_blank" rel="noopener noreferrer">浏览器和Node不同的事件循环（Event Loop）-（node11事件循环和浏览器表现趋于一致）<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <code>推荐</code></p></li> <li><p><a href="https://blog.csdn.net/Fundebug/article/details/86487117" target="_blank" rel="noopener noreferrer">浏览器与Node的事件循环(Event Loop)有何区别?-（node11事件循环和浏览器表现趋于一致）<svg xmlns="http://www.w3.org/2000/svg" aria-labelledby="outbound-link-title" role="img" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><title id="outbound-link-title">(opens new window)</title> <path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <code>推荐</code></p></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">10/10/2020, 9:00:59 AM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e14173b0.js" defer></script><script src="/assets/js/2.138148d6.js" defer></script><script src="/assets/js/6.96633f40.js" defer></script>
  </body>
</html>
